\documentclass[12pt, titlepage]{article}

\usepackage{amsmath, mathtools}

\usepackage[round]{natbib}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{colortbl}
\usepackage{xr}
\usepackage{hyperref}
\usepackage{longtable}
\usepackage{xfrac}
\usepackage{tabularx}
\usepackage{float}
\usepackage{siunitx}
\usepackage{booktabs}
\usepackage{multirow}
\usepackage[section]{placeins}
\usepackage{caption}
\usepackage{fullpage}

\hypersetup{
bookmarks=true,     % show bookmarks bar?
colorlinks=true,       % false: boxed links; true: colored links
linkcolor=red,          % color of internal links (change box color with linkbordercolor)
citecolor=blue,      % color of links to bibliography
filecolor=magenta,  % color of file links
urlcolor=cyan          % color of external links
}

\usepackage{array}

\externaldocument{../../SRS/SRS}

\input{../../Comments}
\input{../../Common}

\begin{document}

\title{Module Interface Specification for \progname{}}

\author{\authname}

\date{\today}

\maketitle

\pagenumbering{roman}

\section{Revision History}

\begin{tabularx}{\textwidth}{p{3cm}p{2cm}X}
\toprule {\bf Date} & {\bf Version} & {\bf Notes}\\
\midrule
Nov 12th & Rev-1 & Module M1-M11\\
Nov 12th & Rev-1 & Module M12-M22\\
Nov 13th & Rev-1 & Fix consistency\\
Nov 13th & Rev-1 & Fix correlation\\
Nov 13th & Rev-1 & Fix consistency\\
Jan 14th & Rev0 & Remove module 20,21,22\\ 
Jan 17th & Rev0 & update m1,4,5,6,9,13,16,17,18\\
Jan 18th & Rev0 & update the remaining part\\
Jan 21th & Rev0 & update notation table, fix some errors from feedback\\
Jan 21th & Rev0 & fixed a table format error\\
\bottomrule
\end{tabularx}

~\newpage

\section{Symbols, Abbreviations and Acronyms}

See MG Documentation at 
\href{https://github.com/The-Crazy-Four-Games/Crazy-Eights-Game/blob/main/docs/Design/SoftArchitecture/MG.pdf}{MG}

\newpage

\tableofcontents

\newpage

\pagenumbering{arabic}

\section{Introduction}

The following document details the Module Interface Specifications for
\progname

Complementary documents include the System Requirement Specifications
and Module Guide.  The full documentation and implementation can be
found at \url{https://github.com/The-Crazy-Four-Games/Crazy-Eights-Game}. 

\section{Notation}

The structure of the MIS for modules comes from \citet{HoffmanAndStrooper1995},
with the addition that template modules have been adapted from
\cite{GhezziEtAl2003}.  The mathematical notation comes from Chapter 3 of
\citet{HoffmanAndStrooper1995}.  For instance, the symbol := is used for a
multiple assignment statement and conditional rules follow the form $(c_1
\Rightarrow r_1 | c_2 \Rightarrow r_2 | ... | c_n \Rightarrow r_n )$.

The following table summarizes the primitive data types used by \progname. 

\begin{center}
\renewcommand{\arraystretch}{1.2}
\noindent 
\begin{tabular}{l l p{7.5cm}} 
\toprule 
\textbf{Data Type} & \textbf{Notation} & \textbf{Description}\\ 
\midrule
character & char & a single symbol or digit\\
integer & $\mathbb{Z}$ & a number without a fractional component in (-$\infty$, $\infty$) \\
natural number & $\mathbb{N}$ & a number without a fractional component in [1, $\infty$) \\
real & $\mathbb{R}$ & any number in (-$\infty$, $\infty$)\\
string & string & an ordered list of characters of any length \\
List of type $T$ & list($T$) & a finite ordered list of elements of type $T$ (order matters) \\
Set of type $T$ & set($T$) & a collection of distinct elements of type $T$ (order does not matter) \\
Map of type $K$ to $V$ & map($K$, $V$) & a mapping from keys of type $K$ to values of type $V$ \\
Tuple of types $T_1, T_2, \ldots$ & tuple($T_1, T_2, \ldots$) & a finite ordered collection of elements of the specified types \\
Optional type $T$ & $T?$ & a value of type $T$ or \textit{None}/null (i.e., the value may be absent) \\
\bottomrule
\end{tabular} 
\end{center}

\noindent
The specification of \progname \ uses some derived data types: sequences, strings, and
tuples. Sequences are lists filled with elements of the same data type. Strings are sequences of characters. Tuples contain a list of values, potentially of
different types. In addition, \progname \ uses functions, which
are defined by the data types of their inputs and outputs. Local functions are
described by giving their type signature followed by their specification.

\section{Module Decomposition}

The following table is taken directly from the Module Guide document for this project.

\begin{table}[H]
\centering
\begin{tabular}{p{0.26\textwidth} p{0.26\textwidth} p{0.44\textwidth}}
\toprule
\textbf{Level 1} & \textbf{Level 2} & \textbf{Level 3 (Leaf Modules)}\\
\midrule

\multirow{1}{0.3\textwidth}{Hardware-Hiding Module} & ~ & (None) \\
\midrule

\multirow{5}{0.3\textwidth}{Behaviour-Hiding Module} & (Core Domain Logic) & \hyperref[sec:game-engine-module]{M15} \\
& & \hyperref[sec:rules-module]{M16} \\
& & \hyperref[sec:scoring-module]{M17} \\
& & \hyperref[sec:base-conversion-module]{M18} \\
& & \hyperref[sec:game-actions-module]{M19} \\

\midrule

\multirow{14}{0.3\textwidth}{Software Decision Module} & \multirow{6}{0.3\textwidth}{Backend (Server)} & \hyperref[sec:api-module]{M1} \\
& & \hyperref[sec:realtime-gateway-module]{M2} \\
& & \hyperref[sec:matchmaking-module]{M3} \\
& & \hyperref[sec:authentication-module]{M4} \\
& & \hyperref[sec:repository-module]{M5} \\
& & \hyperref[sec:audit-module]{M6} \\
\cmidrule{2-3}
& \multirow{8}{0.3\textwidth}{Frontend (Client)} & \hyperref[sec:realtime-client-module]{M7} \\
& & \hyperref[sec:app-shell-module]{M8} \\
& & \hyperref[sec:authentication-client-module]{M9} \\
& & \hyperref[sec:lobby-view-module]{M10} \\
& & \hyperref[sec:game-board-view-module]{M11} \\
& & \hyperref[sec:move-controller-module]{M12} \\
& & \hyperref[sec:scoreboard-view-module]{M13} \\
& & \hyperref[sec:profile-view-module]{M14} \\
\bottomrule

\end{tabular}
\caption{Module Hierarchy}
\label{TblMH}
\end{table}

\newpage
\section{MIS of API Module (M1)}\label{sec:api-module}

\subsection{Module}
API

\subsection{Uses}
\begin{itemize}
    \item \hyperref[sec:authentication-module]{M4 Authentication Module}
    \item \hyperref[sec:repository-module]{M5 Repository Module}
    \item \hyperref[sec:audit-module]{M6 Audit Module}
\end{itemize}

\subsection{Syntax}

\subsubsection{Exported Constants}
\begin{itemize}
    \item \textbf{APIVersion}: string := ``v1''
\end{itemize}

\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{4.5cm} p{4.5cm} p{3.5cm} p{3.5cm}}
\toprule
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\midrule
postRegister & req: RegisterRequest & HttpResponse & BadRequest, UsernameTaken, WeakPassword \\
postLogin & req: LoginRequest & HttpResponse & BadRequest, InvalidCredentials, AccountNotFound \\
postGuestSession & req: GuestSessionRequest & HttpResponse & BadRequest \\
postLogout & req: LogoutRequest & HttpResponse & BadRequest, InvalidToken \\
getProfile & req: AuthenticatedRequest & HttpResponse & Unauthorized, RecordNotFound \\
putProfile & req: UpdateProfileRequest & HttpResponse & BadRequest, Unauthorized, RecordNotFound \\
postNewGame & req: NewGameRequest & HttpResponse & BadRequest, Unauthorized \\
getHealth & req: HttpRequest & HttpResponse & None \\
\bottomrule
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}
None. (Stateless HTTP routes; no persistent state is maintained by this module.)

\subsubsection{Environment Variables}
\begin{itemize}
    \item \textbf{HTTPServer}: The web server/runtime that receives HTTP requests and dispatches routes.
    \item \textbf{Auth}: Authentication service provided by M4.
    \item \textbf{Repository}: Persistence interface provided by M5.
    \item \textbf{Audit}: Audit logging service provided by M6.
\end{itemize}

\subsubsection{Assumptions}
\begin{itemize}
    \item Requests and responses follow the REST endpoint structure and payload schemas defined by the system.
    \item Authentication-protected endpoints include a session token (e.g., \texttt{Authorization} header).
    \item M4, M5, and M6 are correctly configured and available in the server runtime.
\end{itemize}

\subsubsection{Access Routine Semantics}

\noindent\textbf{postRegister}(\textit{req})
\begin{itemize}
    \item transition: Validate \textit{req} payload (username/password). Call \textbf{Auth.createAccount}. Log an authentication audit event via \textbf{Audit.logAuthEvent}.
    \item output: Return \texttt{HttpResponse} containing success status and auth token (on success).
    \item exception: \texttt{BadRequest} if payload invalid. Propagate \texttt{UsernameTaken}/\texttt{WeakPassword} from authentication logic.
\end{itemize}

\noindent\textbf{postLogin}(\textit{req})
\begin{itemize}
    \item transition: Validate \textit{req}. Call \textbf{Auth.login}. Log auth event via \textbf{Audit.logAuthEvent}.
    \item output: Return \texttt{HttpResponse} containing auth token (on success).
    \item exception: \texttt{BadRequest} if payload invalid. \texttt{InvalidCredentials}/\texttt{AccountNotFound} if login fails.
\end{itemize}

\noindent\textbf{postGuestSession}(\textit{req})
\begin{itemize}
    \item transition: Validate \textit{req}. Call \textbf{Auth.createGuestSession}. Log auth event via \textbf{Audit.logAuthEvent}.
    \item output: Return \texttt{HttpResponse} containing guest token.
    \item exception: \texttt{BadRequest} if payload invalid.
\end{itemize}

\noindent\textbf{postLogout}(\textit{req})
\begin{itemize}
    \item transition: Validate \textit{req}. Call \textbf{Auth.logout}. Log auth event via \textbf{Audit.logAuthEvent}.
    \item output: Return \texttt{HttpResponse} confirming logout.
    \item exception: \texttt{BadRequest} if payload invalid. \texttt{InvalidToken} if token invalid.
\end{itemize}

\noindent\textbf{getProfile}(\textit{req})
\begin{itemize}
    \item transition: Verify token from \textit{req} by calling \textbf{Auth.verifyToken}. On success, read user profile from \textbf{Repository} (e.g., \texttt{getPlayerProfile}/equivalent). Log a profile access event via \textbf{Audit.logSystemEvent}.
    \item output: Return \texttt{HttpResponse} containing the user profile data.
    \item exception: \texttt{Unauthorized} if token invalid/expired. \texttt{RecordNotFound} if profile/user does not exist.
\end{itemize}

\noindent\textbf{putProfile}(\textit{req})
\begin{itemize}
    \item transition: Verify token via \textbf{Auth.verifyToken}. Validate profile update payload. Update profile via \textbf{Repository} (e.g., \texttt{updatePlayerProfile}/equivalent). Log update event via \textbf{Audit.logSystemEvent}.
    \item output: Return \texttt{HttpResponse} containing updated profile.
    \item exception: \texttt{BadRequest} if payload invalid. \texttt{Unauthorized} if token invalid/expired. \texttt{RecordNotFound} if user/profile not found.
\end{itemize}

\noindent\textbf{postNewGame}(\textit{req})
\begin{itemize}
    \item transition: Verify token via \textbf{Auth.verifyToken}. Validate request body (game setup parameters). Persist/initialize game bootstrap data via \textbf{Repository} as required by the SRS. Log gameplay/system event via \textbf{Audit.logGameplayEvent} or \textbf{Audit.logSystemEvent}. (Real-time gameplay proceeds through M2.)
    \item output: Return \texttt{HttpResponse} confirming game creation/bootstrapping and any returned identifiers.
    \item exception: \texttt{BadRequest} if payload invalid. \texttt{Unauthorized} if token invalid/expired.
\end{itemize}

\noindent\textbf{getHealth}(\textit{req})
\begin{itemize}
    \item transition: Return basic service status (optionally include shallow checks of dependencies).
    \item output: Return \texttt{HttpResponse} with status \texttt{200 OK} when the API server is up.
    \item exception: None.
\end{itemize}

\subsubsection{Local Functions}
None.

\subsubsection{Considerations}
\begin{itemize}
    \item \textbf{Secret:} REST endpoint structure, request/response payload schemas, and HTTP conventions for stateless backend capabilities.
    \item \textbf{Service:} exposes stateless HTTP routes for authentication, profile management, and bootstrapping new games as defined in the SRS; real-time gameplay is handled separately by M2.
    \item This module should remain stateless; persistence and security concerns are delegated to M5 and M4, while operational logging is delegated to M6.
\end{itemize}


\newpage
\section{MIS of Real-time Gateway Module (M2)}\label{sec:realtime-gateway-module}

\subsection{Module}
Real-time Gateway

\subsection{Uses}
\begin{itemize}
    \item \hyperref[sec:repository-module]{M5 Repository Module}
    \item \hyperref[sec:audit-module]{M6 Audit Module}
    \item \hyperref[sec:game-engine-module]{M15 Game Engine Module}
\end{itemize}

\subsection{Syntax}

\subsubsection{Exported Constants}
None.

\subsubsection{Exported Access Programs}

\begin{center}
    \begin{tabular}{p{4.5cm} p{4cm} p{3.5cm} p{3.5cm}}
        \toprule
        \textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
        \midrule
        handleConnection & socket: ClientSocket & void & SessionError \\
        handleJoinGame & socket: ClientSocket, gameID: GameID & void & SessionError, NotFound \\
        handleSubmitAction & socket: ClientSocket, action: Action & void & InvalidAction, SessionError \\
        registerGameSession & gameID: GameID, state: GameState & void & SessionError \\
        emitGameState & socket: ClientSocket, state: GameState & void &  \\
        broadcastGameState & gameID: GameID, state: GameState & void &  \\
        \bottomrule
    \end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}
\begin{itemize}
    \item \textbf{activeSessions}: Map<GameID, GameState> --- Stores the current authoritative game state for each active game session.
\end{itemize}

\subsubsection{Environment Variables}
\begin{itemize}
    \item \textbf{RealtimeAdapter}: The WebSocket or socket-based runtime environment managing client connections.
    \item \textbf{ClientSocket}: An opaque reference representing a connected client.
\end{itemize}

\subsubsection{Assumptions}
\begin{itemize}
    \item Client connections are established through the \textbf{RealtimeAdapter}.
    \item Game state transitions are processed exclusively through M15.
    \item Persistence and logging services (M5, M6) are available.
\end{itemize}

\subsubsection{Access Routine Semantics}

\noindent\textbf{handleConnection}(\textit{socket})
\begin{itemize}
    \item transition: Registers the \textit{socket} with the \textbf{RealtimeAdapter} and initializes session metadata.
    \item output: \texttt{void}.
    \item exception: \texttt{SessionError} if the connection cannot be established.
\end{itemize}

\noindent\textbf{handleJoinGame}(\textit{socket, gameID})
\begin{itemize}
    \item transition:
    \begin{itemize}
        \item Looks up the game state from \textbf{activeSessions}.
        \item Associates the \textit{socket} with the specified \textit{gameID}.
        \item Logs the join event using M6.
    \end{itemize}
    \item output: Sends the current \texttt{GameState} to the client via \texttt{emitGameState}.
    \item exception: \texttt{NotFound} if the game session does not exist.
\end{itemize}

\noindent\textbf{handleSubmitAction}(\textit{socket, action})
\begin{itemize}
    \item transition:
    \begin{itemize}
        \item Retrieves the associated \texttt{GameState} from \textbf{activeSessions}.
        \item Calls \texttt{M15.processTurn(action)} to validate and apply the action.
        \item Updates the stored \texttt{GameState} with the returned result.
        \item Persists significant state changes using M5.
        \item Logs the action execution using M6.
    \end{itemize}
    \item output: Broadcasts the updated \texttt{GameState} to all connected players.
    \item exception: \texttt{InvalidAction} if the action is rejected by M15.
\end{itemize}

\noindent\textbf{registerGameSession}(\textit{gameID, state})
\begin{itemize}
    \item transition: Inserts a new entry into \textbf{activeSessions}.
    \item output: \texttt{void}.
    \item exception: \texttt{SessionError} if the gameID already exists.
\end{itemize}

\subsubsection{Local Functions}
None.

\subsubsection{Considerations}
\begin{itemize}
    \item \textbf{Secret:} the mapping between client sockets and authoritative game sessions.
    \item This module is server-authoritative but delegates all rule enforcement and state transitions to M15.
    \item Networking concerns are isolated here to avoid coupling game logic with transport mechanisms.
\end{itemize}


\newpage
\section{MIS of Matchmaking Module (M3)}\label{sec:matchmaking-module}

\subsection{Module}
Matchmaking

\subsection{Uses}
\begin{itemize}
    \item \hyperref[sec:realtime-gateway-module]{M2 Real-time Gateway Module}
    \item \hyperref[sec:repository-module]{M5 Repository Module}
\end{itemize}

\subsection{Syntax}

\subsubsection{Exported Constants}
None.

\subsubsection{Exported Access Programs}

\begin{center}
    \begin{tabular}{p{4cm} p{5cm} p{3.5cm} p{3.5cm}}
        \toprule
        \textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
        \midrule
        createLobby & hostID: UserID & LobbyID & LobbyError \\
        joinLobby & lobbyID: LobbyID, userID: UserID & void & LobbyFull, LobbyNotFound \\
        startMatch & lobbyID: LobbyID, hostID: UserID & GameID & LobbyNotFound, NotLobbyHost \\
        \bottomrule
    \end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}
\begin{itemize}
    \item \textbf{lobbies}: Map<LobbyID, Lobby> --- Stores all active waiting lobbies.
\end{itemize}

\subsubsection{Environment Variables}
None.

\subsubsection{Assumptions}
\begin{itemize}
    \item User identities are authenticated before invoking this module.
    \item M2 is available to register real-time game sessions.
    \item Persistent storage (M5) is available.
\end{itemize}

\subsubsection{Access Routine Semantics}

\noindent\textbf{createLobby}(\textit{hostID})
\begin{itemize}
    \item transition:
    \begin{itemize}
        \item Generates a unique \texttt{LobbyID}.
        \item Creates a \texttt{Lobby} object containing \texttt{hostID} and initial player list.
        \item Stores the lobby in \textbf{lobbies}.
        \item Persists lobby metadata via M5.
    \end{itemize}
    \item output: Returns the created \texttt{LobbyID}.
    \item exception: \texttt{LobbyError} if creation fails.
\end{itemize}

\noindent\textbf{joinLobby}(\textit{lobbyID, userID})
\begin{itemize}
    \item transition:
    \begin{itemize}
        \item Retrieves the lobby from \textbf{lobbies}.
        \item Verifies lobby capacity and status.
        \item Adds \textit{userID} to the lobby player list.
        \item Updates lobby state via M5.
    \end{itemize}
    \item output: \texttt{void}.
    \item exception:
    \begin{itemize}
        \item \texttt{LobbyFull} if maximum players reached.
        \item \texttt{LobbyNotFound} if the lobby does not exist.
    \end{itemize}
\end{itemize}

\noindent\textbf{startMatch}(\textit{lobbyID, hostID})
\begin{itemize}
    \item transition:
    \begin{itemize}
        \item Retrieves the lobby from \textbf{lobbies}.
        \item Verifies \textit{hostID} matches the lobby host.
        \item Generates a \texttt{GameID}.
        \item Calls \texttt{M2.registerGameSession(GameID, lobby.players)}.
        \item Removes the lobby from \textbf{lobbies}.
        \item Persists match metadata via M5.
    \end{itemize}
    \item output: Returns the generated \texttt{GameID}.
    \item exception:
    \begin{itemize}
        \item \texttt{LobbyNotFound} if the lobby does not exist.
        \item \texttt{NotLobbyHost} if the caller is not the lobby host.
    \end{itemize}
\end{itemize}

\subsubsection{Local Functions}
None.

\subsubsection{Considerations}
\begin{itemize}
    \item \textbf{Secret:} lobby lifecycle management and session handoff logic.
    \item This module deliberately avoids any game rule or state logic.
    \item All real-time behavior is delegated to M2 after match creation.
\end{itemize}

\newpage
\section{MIS of Authentication Module (M4)}\label{sec:authentication-module}

\subsection{Module}
Authentication

\subsection{Uses}
None.

\subsection{Syntax}

\subsubsection{Exported Constants}
None.

\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{4.5cm} p{4.5cm} p{3.5cm} p{3.5cm}}
\toprule
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\midrule
createAccount & username: string, password: string & AuthResult & UsernameTaken, WeakPassword, CredentialStoreError \\
login & username: string, password: string & AuthResult & InvalidCredentials, AccountNotFound, CredentialStoreError \\
createGuestSession & deviceId: string & AuthResult & CredentialStoreError \\
logout & token: SessionToken & void & InvalidToken \\
issueToken & userId: UserID, role: UserRole & SessionToken & TokenSigningError \\
verifyToken & token: SessionToken & TokenClaims & InvalidToken, ExpiredToken, TokenSigningError \\
refreshToken & token: SessionToken & SessionToken & InvalidToken, ExpiredToken, TokenSigningError \\
\bottomrule
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}
\begin{itemize}
    \item \textbf{hashConfig}: Configuration for password hashing (e.g., algorithm selection, cost parameters).
    \item \textbf{tokenSigner}: A component holding token-signing capability (e.g., HMAC secret or private key handle).
    \item \textbf{credentialStore}: Internal credential storage mechanism used by this module (implementation-defined).
    \item \textbf{activeSessions}: A mapping from \texttt{SessionToken} to session metadata (e.g., \texttt{userId}, \texttt{expiry}, \texttt{role}). (If sessions are stateless JWTs, this may be minimal or omitted.)
\end{itemize}

\subsubsection{Environment Variables}
\begin{itemize}
    \item \textbf{TokenSigningKey}: Secret key material used to sign/verify tokens (stored securely outside the codebase).
    \item \textbf{SystemClock}: Source of current time used for expiry validation.
\end{itemize}

\subsubsection{Assumptions}
\begin{itemize}
    \item Password hashing configuration is correctly set and kept consistent across deployments.
    \item \textbf{TokenSigningKey} is available and protected (not exposed to clients).
    \item The internal \textbf{credentialStore} is available and correctly initialized.
\end{itemize}

\subsubsection{Access Routine Semantics}

\noindent\textbf{createAccount}(\textit{username, password})
\begin{itemize}
    \item transition: Validate \textit{username} format and \textit{password} strength. Hash \textit{password} using \textbf{hashConfig}. Store account and credential info in \textbf{credentialStore}. Issue a session token for the new account via \textbf{issueToken}.
    \item output: Return \texttt{AuthResult} containing (at minimum) a \texttt{SessionToken} and user identity information.
    \item exception: \texttt{UsernameTaken} if \textit{username} already exists in \textbf{credentialStore}. \texttt{WeakPassword} if \textit{password} fails policy. \texttt{CredentialStoreError} if storage fails.
\end{itemize}

\noindent\textbf{login}(\textit{username, password})
\begin{itemize}
    \item transition: Retrieve credential record for \textit{username} from \textbf{credentialStore}. Verify \textit{password} against stored hash. On success, issue a new token via \textbf{issueToken}.
    \item output: Return \texttt{AuthResult} containing a valid \texttt{SessionToken}.
    \item exception: \texttt{AccountNotFound} if \textit{username} does not exist. \texttt{InvalidCredentials} if verification fails. \texttt{CredentialStoreError} if retrieval fails.
\end{itemize}

\noindent\textbf{createGuestSession}(\textit{deviceId})
\begin{itemize}
    \item transition: Create or reuse a guest identity bound to \textit{deviceId} (policy-defined). Store minimal guest metadata in \textbf{credentialStore} if required. Issue a guest token via \textbf{issueToken}.
    \item output: Return \texttt{AuthResult} containing a guest \texttt{SessionToken}.
    \item exception: \texttt{CredentialStoreError} if storage fails.
\end{itemize}

\noindent\textbf{logout}(\textit{token})
\begin{itemize}
    \item transition: Invalidate \textit{token}. If tokens are stateless, record the token (or its identifier) in a denylist until expiry; otherwise remove from \textbf{activeSessions}.
    \item output: \texttt{void}.
    \item exception: \texttt{InvalidToken} if \textit{token} is malformed or cannot be invalidated under the configured policy.
\end{itemize}

\noindent\textbf{issueToken}(\textit{userId, role})
\begin{itemize}
    \item transition: Construct token claims (e.g., \textit{userId}, \textit{role}, issued-at, expiry). Sign token using \textbf{tokenSigner} backed by \textbf{TokenSigningKey}.
    \item output: Return a signed \texttt{SessionToken}.
    \item exception: \texttt{TokenSigningError} if signing fails or key material is unavailable.
\end{itemize}

\noindent\textbf{verifyToken}(\textit{token})
\begin{itemize}
    \item transition: Verify signature using \textbf{TokenSigningKey}. Validate expiry against \textbf{SystemClock}. Optionally check denylist / \textbf{activeSessions}.
    \item output: Return \texttt{TokenClaims} extracted from the token.
    \item exception: \texttt{InvalidToken} if signature/format validation fails. \texttt{ExpiredToken} if expiry has passed. \texttt{TokenSigningError} if verification fails due to key issues.
\end{itemize}

\noindent\textbf{refreshToken}(\textit{token})
\begin{itemize}
    \item transition: Verify \textit{token} via \textbf{verifyToken}. If eligible for refresh, issue a new token with extended expiry via \textbf{issueToken}. Optionally revoke the old token (denylist) depending on policy.
    \item output: Return a new \texttt{SessionToken}.
    \item exception: \texttt{InvalidToken} if verification fails. \texttt{ExpiredToken} if the token is no longer refreshable. \texttt{TokenSigningError} if issuing the new token fails.
\end{itemize}

\subsubsection{Local Functions}
None.

\subsubsection{Considerations}
\begin{itemize}
    \item \textbf{Secret:} password hashing configuration, credential storage details, and token-signing keys.
    \item \textbf{Service:} creates accounts, validates logins, manages guest sessions, and issues/verifies tokens used by the rest of the backend.
    \item Other backend modules should not handle raw passwords or token signing directly; they should rely on this module's access routines.
    \item If hashing algorithms or token mechanisms change, modifications are localized to this module; callers remain unchanged.
\end{itemize}

\newpage
\section{MIS of Repository Module (M5)}\label{sec:repository-module}

\subsection{Module}
Repository

\subsection{Uses}
None.

\subsection{Syntax}

\subsubsection{Exported Constants}
None.

\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{4.5cm} p{4.5cm} p{3.5cm} p{3.5cm}}
\toprule
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\midrule
findPlayerByUsername & username: string & Player & RecordNotFound, DatabaseConnectionError \\
findPlayerById & playerId: PlayerID & Player & RecordNotFound, DatabaseConnectionError \\
createPlayer & data: PlayerData & Player & UniqueConstraintViolation, DatabaseConnectionError \\
updatePlayerProfile & playerId: PlayerID, data: PlayerProfileData & Player & RecordNotFound, DatabaseConnectionError \\
storeCredential & playerId: PlayerID, cred: CredentialData & void & RecordNotFound, UniqueConstraintViolation, DatabaseConnectionError \\
getCredentialByUsername & username: string & CredentialRecord & RecordNotFound, DatabaseConnectionError \\
saveMatchResult & result: MatchResult & void & DatabaseConnectionError \\
getMatchHistory & playerId: PlayerID, limit: nat, offset: nat & seq of MatchResult & DatabaseConnectionError \\
getPlayerStats & playerId: PlayerID & PlayerStats & RecordNotFound, DatabaseConnectionError \\
deletePlayer & playerId: PlayerID & void & RecordNotFound, DatabaseConnectionError \\
\bottomrule
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}
\begin{itemize}
    \item \textbf{dbConnectionPool}: A connection pool managing active connections to the PostgreSQL database.
\end{itemize}

\subsubsection{Environment Variables}
\begin{itemize}
    \item \textbf{PostgreSQLServer}: The external PostgreSQL database instance that executes all SQL queries.
    \item \textbf{DBConnectionString}: A secure configuration value used to initialize database connectivity.
\end{itemize}

\subsubsection{Assumptions}
\begin{itemize}
    \item \textbf{PostgreSQLServer} is running and reachable from the server-side runtime.
    \item \textbf{DBConnectionString} is provided securely and grants appropriate permissions.
    \item The database schema for players, credentials, match history, and statistics is initialized and consistent with this module's queries.
\end{itemize}

\subsubsection{Access Routine Semantics}

\noindent\textbf{findPlayerByUsername}(\textit{username})
\begin{itemize}
    \item transition: Acquire a connection from \textbf{dbConnectionPool}. Execute a SQL \texttt{SELECT} over the player table filtered by \textit{username}.
    \item output: Return the \texttt{Player} record.
    \item exception: \texttt{RecordNotFound} if no player matches \textit{username}. \texttt{DatabaseConnectionError} if query/connection fails.
\end{itemize}

\noindent\textbf{findPlayerById}(\textit{playerId})
\begin{itemize}
    \item transition: Acquire a connection. Execute a SQL \texttt{SELECT} over the player table filtered by \textit{playerId}.
    \item output: Return the \texttt{Player} record.
    \item exception: \texttt{RecordNotFound} if \textit{playerId} does not exist. \texttt{DatabaseConnectionError} if query/connection fails.
\end{itemize}

\noindent\textbf{createPlayer}(\textit{data})
\begin{itemize}
    \item transition: Acquire a connection. Execute a SQL \texttt{INSERT} to create a new player using \textit{data}.
    \item output: Return the created \texttt{Player} (including generated \texttt{PlayerID}).
    \item exception: \texttt{UniqueConstraintViolation} if a unique field (e.g., username) already exists. \texttt{DatabaseConnectionError} if query/connection fails.
\end{itemize}

\noindent\textbf{updatePlayerProfile}(\textit{playerId, data})
\begin{itemize}
    \item transition: Acquire a connection. Execute a SQL \texttt{UPDATE} to modify the profile fields for \textit{playerId} using \textit{data}.
    \item output: Return the updated \texttt{Player}.
    \item exception: \texttt{RecordNotFound} if \textit{playerId} does not exist. \texttt{DatabaseConnectionError} if query/connection fails.
\end{itemize}

\noindent\textbf{storeCredential}(\textit{playerId, cred})
\begin{itemize}
    \item transition: Acquire a connection. Execute a SQL \texttt{INSERT} (or \texttt{UPSERT}, if supported by the schema) to store credential material for \textit{playerId}.
    \item output: \texttt{void}.
    \item exception: \texttt{RecordNotFound} if \textit{playerId} does not exist. \texttt{UniqueConstraintViolation} if the credential record violates a uniqueness rule. \texttt{DatabaseConnectionError} if query/connection fails.
\end{itemize}

\noindent\textbf{getCredentialByUsername}(\textit{username})
\begin{itemize}
    \item transition: Acquire a connection. Execute a SQL \texttt{SELECT} joining username $\rightarrow$ player $\rightarrow$ credential record (schema-dependent).
    \item output: Return the \texttt{CredentialRecord}.
    \item exception: \texttt{RecordNotFound} if no credential is found for \textit{username}. \texttt{DatabaseConnectionError} if query/connection fails.
\end{itemize}

\noindent\textbf{saveMatchResult}(\textit{result})
\begin{itemize}
    \item transition: Acquire a connection. Execute a SQL \texttt{INSERT} into match history / results tables using \textit{result}.
    \item output: \texttt{void}.
    \item exception: \texttt{DatabaseConnectionError} if query/connection fails.
\end{itemize}

\noindent\textbf{getMatchHistory}(\textit{playerId, limit, offset})
\begin{itemize}
    \item transition: Acquire a connection. Execute a SQL \texttt{SELECT} over match history filtered by \textit{playerId}, ordered by time, returning a window defined by \textit{limit} and \textit{offset}.
    \item output: Return a sequence of \texttt{MatchResult}.
    \item exception: \texttt{DatabaseConnectionError} if query/connection fails.
\end{itemize}

\noindent\textbf{getPlayerStats}(\textit{playerId})
\begin{itemize}
    \item transition: Acquire a connection. Execute a SQL \texttt{SELECT} (and/or aggregate queries) to retrieve computed statistics for \textit{playerId}.
    \item output: Return \texttt{PlayerStats}.
    \item exception: \texttt{RecordNotFound} if \textit{playerId} does not exist (or has no stats record per schema). \texttt{DatabaseConnectionError} if query/connection fails.
\end{itemize}

\noindent\textbf{deletePlayer}(\textit{playerId})
\begin{itemize}
    \item transition: Acquire a connection. Execute SQL \texttt{DELETE} operations (possibly cascading per schema) to remove the player and related records.
    \item output: \texttt{void}.
    \item exception: \texttt{RecordNotFound} if \textit{playerId} does not exist. \texttt{DatabaseConnectionError} if query/connection fails.
\end{itemize}

\subsubsection{Local Functions}
None.

\subsubsection{Considerations}
\begin{itemize}
    \item \textbf{Secret:} the database implementation (PostgreSQL), schema design, optimized SQL queries, and database access strategies (e.g., pooling, transactions).
    \item \textbf{Service:} provides a clean persistence interface for storing and retrieving players, credentials, match history, and statistics, shielding callers from database specifics.
    \item This module abstracts all CRUD operations and schema details; callers never issue SQL directly.
    \item If the persistence technology changes (e.g., PostgreSQL to another DB), only this module needs to be rewritten; callers remain unchanged.
\end{itemize}

\newpage
\section{MIS of Audit Module (M6)}\label{sec:audit-module}

\subsection{Module}
Audit

\subsection{Uses}
None.

\subsection{Syntax}

\subsubsection{Exported Constants}
\begin{itemize}
    \item \textbf{DefaultRetentionDays}: nat := 30
    \item \textbf{MaxEventPayloadSize}: nat := 8192 \quad (bytes)
\end{itemize}

\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{4.5cm} p{4.5cm} p{3.5cm} p{3.5cm}}
\toprule
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\midrule
logAuthEvent & event: AuthAuditEvent & void & LogStoreError \\
logGameplayEvent & event: GameplayAuditEvent & void & LogStoreError \\
logSystemEvent & event: SystemAuditEvent & void & LogStoreError \\
queryAuditEvents & filter: AuditQueryFilter & seq of AuditEvent & LogStoreError \\
purgeExpiredEvents & retentionDays: nat & nat & LogStoreError \\
redactEventPayload & eventId: AuditEventID, fields: seq of string & void & RecordNotFound, LogStoreError \\
\bottomrule
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}
\begin{itemize}
    \item \textbf{retentionPolicyDays}: nat := \textbf{DefaultRetentionDays}
    \item \textbf{logStore}: Internal storage target/driver for audit events (implementation-defined; may be DB table, file sink, external log service).
\end{itemize}

\subsubsection{Environment Variables}
\begin{itemize}
    \item \textbf{SystemClock}: Source of current time for timestamps and retention enforcement.
    \item \textbf{AuditStorageConfig}: Configuration describing storage target(s), retention, and access credentials for the logging backend.
\end{itemize}

\subsubsection{Assumptions}
\begin{itemize}
    \item The event schema (fields for authentication/gameplay/system events) matches the storage format used by \textbf{logStore}.
    \item The storage target(s) configured by \textbf{AuditStorageConfig} are reachable during normal operation.
    \item Retention policies are chosen to satisfy operational debugging, security, and compliance requirements.
\end{itemize}

\subsubsection{Access Routine Semantics}

\noindent\textbf{logAuthEvent}(\textit{event})
\begin{itemize}
    \item transition: Validate \textit{event} payload size $\le$ \textbf{MaxEventPayloadSize}. Attach timestamp from \textbf{SystemClock}. Serialize and append/store in \textbf{logStore} using the authentication-event schema.
    \item output: \texttt{void}.
    \item exception: \texttt{LogStoreError} if storage/append fails.
\end{itemize}

\noindent\textbf{logGameplayEvent}(\textit{event})
\begin{itemize}
    \item transition: Validate payload size and required fields. Attach timestamp. Serialize and append/store in \textbf{logStore} using the gameplay-event schema.
    \item output: \texttt{void}.
    \item exception: \texttt{LogStoreError} if storage/append fails.
\end{itemize}

\noindent\textbf{logSystemEvent}(\textit{event})
\begin{itemize}
    \item transition: Validate payload size and required fields. Attach timestamp. Serialize and append/store in \textbf{logStore} using the system-event schema.
    \item output: \texttt{void}.
    \item exception: \texttt{LogStoreError} if storage/append fails.
\end{itemize}

\noindent\textbf{queryAuditEvents}(\textit{filter})
\begin{itemize}
    \item transition: Translate \textit{filter} constraints (time window, event type, user/session identifiers, severity, correlation id, etc.) into \textbf{logStore} query operations. Execute query against \textbf{logStore}. Apply any post-filters (e.g., pagination) as required.
    \item output: Return a sequence of \texttt{AuditEvent} matching \textit{filter}.
    \item exception: \texttt{LogStoreError} if querying fails.
\end{itemize}

\noindent\textbf{purgeExpiredEvents}(\textit{retentionDays})
\begin{itemize}
    \item transition: Compute cutoff time = \textbf{SystemClock} $-$ \textit{retentionDays}. Delete, archive, or compact entries older than cutoff according to \textbf{AuditStorageConfig} policy.
    \item output: Return the number of events purged (nat).
    \item exception: \texttt{LogStoreError} if purge/archive fails.
\end{itemize}

\noindent\textbf{redactEventPayload}(\textit{eventId, fields})
\begin{itemize}
    \item transition: Locate \textit{eventId} in \textbf{logStore}. Replace, mask, or remove specified \textit{fields} in the persisted payload (schema-dependent). Persist the redacted version and mark the record as redacted.
    \item output: \texttt{void}.
    \item exception: \texttt{RecordNotFound} if \textit{eventId} does not exist. \texttt{LogStoreError} if update/writeback fails.
\end{itemize}

\subsubsection{Local Functions}
None.

\subsubsection{Considerations}
\begin{itemize}
    \item \textbf{Secret:} the exact event schema, retention policy, and storage targets for operational logs.
    \item \textbf{Service:} captures authentication, gameplay, and system events to support debugging, compliance, security, and user inquiries.
    \item This module is a library utility; it should not impose dependencies on other modules.
    \item If storage targets or retention strategies change, updates are localized to this module; event producers remain unchanged as long as the API is stable.
\end{itemize}

\newpage
\section{MIS of Real-time Client Module (M7)}\label{sec:realtime-client-module}

\subsection{Module}
Real-time Client

\subsection{Uses}
\begin{itemize}
    \item \hyperref[sec:realtime-gateway-module]{M2 Real-time Gateway Module}
\end{itemize}

\subsection{Syntax}

\subsubsection{Exported Constants}
None.

\subsubsection{Exported Access Programs}

\begin{center}
    \begin{tabular}{p{4cm} p{5cm} p{3cm} p{3.5cm}}
        \toprule
        \textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
        \midrule
        connect & serverURL: string & void & ConnectionFailed \\
        disconnect & -- & void & -- \\
        emit & event: string, payload: Data & void & ConnectionFailed \\
        on & event: string, handler: Callback & void & -- \\
        \bottomrule
    \end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}
\begin{itemize}
    \item \textbf{socket}: ClientSocket --- Active real-time connection handle.
    \item \textbf{connected}: boolean --- Indicates connection status.
\end{itemize}

\subsubsection{Environment Variables}
\begin{itemize}
    \item \textbf{ClientRuntime}: Execution environment providing networking support (e.g., WebSocket).
\end{itemize}

\subsubsection{Assumptions}
\begin{itemize}
    \item M2 is reachable at the provided server URL.
    \item Network connectivity may be intermittent.
\end{itemize}

\subsubsection{Access Routine Semantics}

\noindent\textbf{connect}(\textit{serverURL})
\begin{itemize}
    \item transition:
    \begin{itemize}
        \item Establishes a real-time connection to M2.
        \item Initializes \textbf{socket}.
        \item Sets \textbf{connected} := true on success.
    \end{itemize}
    \item output: \texttt{void}.
    \item exception: \texttt{ConnectionFailed} if the server is unreachable.
\end{itemize}

\noindent\textbf{disconnect}()
\begin{itemize}
    \item transition:
    \begin{itemize}
        \item Terminates the active connection.
        \item Sets \textbf{connected} := false.
        \item Releases \textbf{socket}.
    \end{itemize}
    \item output: \texttt{void}.
\end{itemize}

\noindent\textbf{emit}(\textit{event, payload})
\begin{itemize}
    \item transition:
    \begin{itemize}
        \item Serializes \textit{payload}.
        \item Sends the event and payload to M2 through \textbf{socket}.
    \end{itemize}
    \item output: \texttt{void}.
    \item exception: \texttt{ConnectionFailed} if \textbf{connected} is false.
\end{itemize}

\noindent\textbf{on}(\textit{event, handler})
\begin{itemize}
    \item transition:
    \begin{itemize}
        \item Registers \textit{handler} to be invoked when M2 emits \textit{event}.
    \end{itemize}
    \item output: \texttt{void}.
\end{itemize}

\subsubsection{Local Functions}
None.

\subsubsection{Considerations}
\begin{itemize}
    \item \textbf{Secret:} connection lifecycle handling and event dispatch mechanism.
    \item This module abstracts real-time communication details from higher-level client modules.
    \item No game logic or UI logic is included in this module.
\end{itemize}


\newpage
\section{MIS of Application Shell Module (M8)}\label{sec:app-shell-module}

\subsection{Module}
Application Shell

\subsection{Uses}
\begin{itemize}
    \item \hyperref[sec:authentication-client-module]{M9 Authentication Client Module}
\end{itemize}

\subsection{Syntax}

\subsubsection{Exported Constants}
None.

\subsubsection{Exported Access Programs}

\begin{center}
    \begin{tabular}{p{4.5cm} p{4.5cm} p{3.5cm} p{3.5cm}}
        \toprule
        \textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
        \midrule
        Render & route: Route, auth: AuthState & ViewModel & RouteNotFound \\
        \bottomrule
    \end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}
\begin{itemize}
    \item \textbf{currentUser}: User? --- The currently authenticated user, if any.
    \item \textbf{currentRoute}: Route --- The currently selected navigation route.
\end{itemize}

\subsubsection{Environment Variables}
\begin{itemize}
    \item \textbf{NavigationContext}: An external source of navigation state that provides the current route (e.g., a URL path or navigation stack).
\end{itemize}

\subsubsection{Assumptions}
\begin{itemize}
    \item Authentication state (logged-in vs. guest vs. logged-out) is obtained exclusively through M9.
    \item Route selection and access gating are based on \textbf{currentUser} and \textbf{currentRoute}.
\end{itemize}

\subsubsection{Access Routine Semantics}

\noindent\textbf{Render}(\textit{route, auth})
\begin{itemize}
    \item transition:
    \begin{itemize}
        \item Updates \textbf{currentRoute} $\leftarrow$ \textit{route}.
        \item Updates \textbf{currentUser} based on \textit{auth} (obtained via M9).
        \item Applies access control rules to determine the effective route:
              if \textbf{currentUser} is absent and \textbf{currentRoute} requires authentication,
              then \textbf{currentRoute} is set to the login route.
    \end{itemize}
    \item output:
    Returns a \textit{ViewModel} describing the global application layout (e.g., header/footer)
    and the active page/view corresponding to \textbf{currentRoute}.
    \item exception: \texttt{RouteNotFound} if \textbf{currentRoute} does not match any entry in the routing table.
\end{itemize}

\subsubsection{Local Functions}
None.

\subsubsection{Considerations}
\begin{itemize}
    \item \textbf{Secret:} the application routing table and the layout composition strategy.
    \item \textbf{Service:} provides the top-level structure for the client application and enforces authentication gating by relying only on M9 for auth state.
    \item This module contains no gameplay logic; it only coordinates navigation and top-level rendering.
\end{itemize}

\newpage
\section{MIS of Authentication Client Module (M9)}\label{sec:authentication-client-module}

\subsection{Module}
Authentication Client

\subsection{Uses}
\begin{itemize}
    \item \hyperref[sec:api-module]{M1 API Module}
\end{itemize}

\subsection{Syntax}

\subsubsection{Exported Constants}
\begin{itemize}
    \item \textbf{TokenStorageKey}: string := ``authToken''
\end{itemize}

\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{4.5cm} p{4.5cm} p{3.5cm} p{3.5cm}}
\toprule
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\midrule
renderLoginForm & None & ViewModel & None \\
renderSignupForm & None & ViewModel & None \\
submitLogin & username: string, password: string & AuthViewState & InvalidInput, AuthFailed, NetworkError \\
submitSignup & username: string, password: string & AuthViewState & InvalidInput, AuthFailed, NetworkError \\
submitLogout & None & AuthViewState & NetworkError \\
storeToken & token: string & void & TokenStorageError \\
loadToken & None & OptionalString & TokenStorageError \\
clearToken & None & void & TokenStorageError \\
\bottomrule
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}
\begin{itemize}
    \item \textbf{currentToken}: OptionalString \quad (cached token currently held by the client)
    \item \textbf{authStatus}: AuthStatus \quad (e.g., \texttt{LoggedOut}, \texttt{LoggingIn}, \texttt{LoggedIn}, \texttt{Error})
\end{itemize}

\subsubsection{Environment Variables}
\begin{itemize}
    \item \textbf{ClientRuntime}: Browser/client framework runtime that renders UI and handles events.
    \item \textbf{SecureStorage}: Client-side storage mechanism (e.g., cookie/local storage/session storage), implementation-defined.
\end{itemize}

\subsubsection{Assumptions}
\begin{itemize}
    \item The client calls M1 for authentication-related HTTP requests (login/signup/logout).
    \item Token storage is best-effort secure according to the chosen client storage mechanism.
    \item Network calls may fail; the UI reports errors to the user.
\end{itemize}

\subsubsection{Access Routine Semantics}

\noindent\textbf{renderLoginForm}()
\begin{itemize}
    \item transition: Construct a login form view model (username/password inputs, submit action, error placeholder).
    \item output: Return the \texttt{ViewModel} for the login form.
    \item exception: None.
\end{itemize}

\noindent\textbf{renderSignupForm}()
\begin{itemize}
    \item transition: Construct a signup form view model (username/password inputs, submit action, error placeholder).
    \item output: Return the \texttt{ViewModel} for the signup form.
    \item exception: None.
\end{itemize}

\noindent\textbf{submitLogin}(\textit{username, password})
\begin{itemize}
    \item transition: Validate inputs (non-empty, basic format checks). Call M1 authentication route (e.g., \texttt{postLogin}). On success, extract token from the response and call \textbf{storeToken}. Update \textbf{currentToken} and \textbf{authStatus}.
    \item output: Return \texttt{AuthViewState} indicating success/failure and any user-facing message.
    \item exception: \texttt{InvalidInput} if validation fails. \texttt{AuthFailed} if server rejects credentials. \texttt{NetworkError} if request fails.
\end{itemize}

\noindent\textbf{submitSignup}(\textit{username, password})
\begin{itemize}
    \item transition: Validate inputs. Call M1 authentication route (e.g., \texttt{postRegister}). On success, store returned token via \textbf{storeToken}. Update \textbf{currentToken} and \textbf{authStatus}.
    \item output: Return \texttt{AuthViewState} indicating success/failure and any user-facing message.
    \item exception: \texttt{InvalidInput} if validation fails. \texttt{AuthFailed} if server rejects signup. \texttt{NetworkError} if request fails.
\end{itemize}

\noindent\textbf{submitLogout}()
\begin{itemize}
    \item transition: If \textbf{currentToken} exists, call M1 logout route (e.g., \texttt{postLogout}) best-effort. Call \textbf{clearToken}. Set \textbf{currentToken} := None and \textbf{authStatus} := \texttt{LoggedOut}.
    \item output: Return \texttt{AuthViewState} indicating the user is logged out.
    \item exception: \texttt{NetworkError} if the logout request fails (token clearing still proceeds locally).
\end{itemize}

\noindent\textbf{storeToken}(\textit{token})
\begin{itemize}
    \item transition: Persist \textit{token} into \textbf{SecureStorage} under \textbf{TokenStorageKey}. Set \textbf{currentToken} := \textit{token}.
    \item output: \texttt{void}.
    \item exception: \texttt{TokenStorageError} if the storage operation fails.
\end{itemize}

\noindent\textbf{loadToken}()
\begin{itemize}
    \item transition: Read token from \textbf{SecureStorage} under \textbf{TokenStorageKey}. If present, set \textbf{currentToken} := token; otherwise set \textbf{currentToken} := None.
    \item output: Return \textbf{currentToken}.
    \item exception: \texttt{TokenStorageError} if the storage read fails.
\end{itemize}

\noindent\textbf{clearToken}()
\begin{itemize}
    \item transition: Remove \textbf{TokenStorageKey} from \textbf{SecureStorage}. Set \textbf{currentToken} := None.
    \item output: \texttt{void}.
    \item exception: \texttt{TokenStorageError} if removal fails.
\end{itemize}

\subsubsection{Local Functions}
None.

\subsubsection{Considerations}
\begin{itemize}
    \item \textbf{Secret:} decisions about secure token storage and the flows for refreshing or clearing credentials in the browser.
    \item \textbf{Service:} presents login, signup, and logout experiences while coordinating with \textbf{M1} for authentication calls.
    \item \textbf{Type Note:} \texttt{OptionalString = string $\cup$ \{None\}}.
\end{itemize}

\newpage
\section{MIS of Lobby View Module (M10)}\label{sec:lobby-view-module}

\subsection{Module}
Lobby View

\subsection{Uses}
\begin{itemize}
    \item \hyperref[sec:api-module]{M1 API Module}
    \item \hyperref[sec:realtime-client-module]{M7 Real-time Client Module}
\end{itemize}

\subsection{Syntax}

\subsubsection{Exported Constants}
None.

\subsubsection{Exported Access Programs}

\begin{center}
    \begin{tabular}{p{4.5cm} p{5cm} p{3.5cm} p{3.5cm}}
        \toprule
        \textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
        \midrule
        Render & props: ViewProps & ViewModel & None \\
        handleCreateLobby & token: SessionToken & LobbyID & CreateLobbyError, NetworkError \\
        handleJoinLobby & token: SessionToken, lobbyID: LobbyID & void & JoinLobbyError, NetworkError \\
        handleStartMatch & token: SessionToken, lobbyID: LobbyID & GameID & StartMatchError, NetworkError \\
        subscribeLobbyUpdates & lobbyID: LobbyID & void & ConnectionFailed \\
        \bottomrule
    \end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}
\begin{itemize}
    \item \textbf{availableLobbies}: seq of LobbySummary --- List of lobbies shown to the user.
    \item \textbf{selectedLobby}: LobbyID $\cup$ \{None\} --- Currently selected lobby.
    \item \textbf{statusMessage}: string --- UI feedback text (errors/loading).
    \item \textbf{isLoading}: boolean --- True while an operation is in progress.
\end{itemize}

\subsubsection{Environment Variables}
\begin{itemize}
    \item \textbf{ClientRuntime}: UI runtime responsible for rendering view models and handling user input events.
\end{itemize}

\subsubsection{Assumptions}
\begin{itemize}
    \item The user is authenticated and a valid \texttt{SessionToken} is available when creating/joining/starting a match.
    \item M1 provides HTTP endpoints for lobby and match operations.
    \item M7 is able to connect to the real-time server and subscribe to lobby/game updates.
\end{itemize}

\subsubsection{Access Routine Semantics}

\noindent\textbf{Render}(\textit{props})
\begin{itemize}
    \item transition: Updates the displayed lobby list and user interaction controls using current state variables.
    \item output: Returns a \texttt{ViewModel} representing the lobby UI (list of lobbies, create/join/start controls, status messages).
    \item exception: None.
\end{itemize}

\noindent\textbf{handleCreateLobby}(\textit{token})
\begin{itemize}
    \item transition:
    \begin{itemize}
        \item Sets \textbf{isLoading} := true.
        \item Calls M1 to request lobby creation using \textit{token}.
        \item On success, sets \textbf{selectedLobby} to the returned \texttt{LobbyID}.
    \end{itemize}
    \item output: Returns the created \texttt{LobbyID}.
    \item exception: \texttt{CreateLobbyError} if the server rejects the request; \texttt{NetworkError} if the request fails.
\end{itemize}

\noindent\textbf{handleJoinLobby}(\textit{token, lobbyID})
\begin{itemize}
    \item transition:
    \begin{itemize}
        \item Sets \textbf{isLoading} := true.
        \item Calls M1 to request joining \textit{lobbyID} using \textit{token}.
        \item On success, calls \textbf{subscribeLobbyUpdates}(\textit{lobbyID}) to listen for real-time status changes.
    \end{itemize}
    \item output: \texttt{void}.
    \item exception: \texttt{JoinLobbyError} if lobby is full/not found/rejected; \texttt{NetworkError} if request fails.
\end{itemize}

\noindent\textbf{handleStartMatch}(\textit{token, lobbyID})
\begin{itemize}
    \item transition:
    \begin{itemize}
        \item Calls M1 to start a match for \textit{lobbyID}.
        \item Receives a \texttt{GameID}.
        \item Uses M7 to subscribe to real-time updates for the created game session (implementation-defined event name).
    \end{itemize}
    \item output: Returns \texttt{GameID}.
    \item exception: \texttt{StartMatchError} if the server rejects start; \texttt{NetworkError} if request fails.
\end{itemize}

\noindent\textbf{subscribeLobbyUpdates}(\textit{lobbyID})
\begin{itemize}
    \item transition:
    \begin{itemize}
        \item Ensures M7 is connected (calls \texttt{M7.connect} if required).
        \item Registers event handlers via \texttt{M7.on} to receive lobby status updates and update \textbf{availableLobbies}/\textbf{statusMessage}.
    \end{itemize}
    \item output: \texttt{void}.
    \item exception: \texttt{ConnectionFailed} if M7 cannot connect.
\end{itemize}

\subsubsection{Local Functions}
None.

\subsubsection{Considerations}
\begin{itemize}
    \item \textbf{Secret:} UI-level flow for lobby creation/joining/starting and how lobby updates are presented.
    \item This module performs no game logic; it only coordinates HTTP calls (M1) and real-time subscriptions (M7).
\end{itemize}


\newpage
\section{MIS of Game Board View Module (M11)}\label{sec:game-board-view-module}

\subsection{Module}
Game Board View

\subsection{Uses}
\begin{itemize}
    \item \hyperref[sec:move-controller-module]{M12 Move Controller Module}
    \item \hyperref[sec:scoreboard-view-module]{M13 Scoreboard View Module}
\end{itemize}

\subsection{Syntax}

\subsubsection{Exported Constants}
None.

\subsubsection{Exported Access Programs}

\begin{center}
    \begin{tabular}{p{4.5cm} p{5cm} p{3.5cm} p{3.5cm}}
        \toprule
        \textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
        \midrule
        Render & state: RoundState, playerId: PlayerID, scores: ScoreboardData & ViewModel & None \\
        onSelectCard & card: Card & void & None \\
        onPlaySelected & chosenSuit: Suit? & void & InvalidMoveUI, ConnectionFailed \\
        onDraw & -- & void & InvalidMoveUI, ConnectionFailed \\
        \bottomrule
    \end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}
\begin{itemize}
    \item \textbf{selectedCard}: Card $\cup$ \{None\} --- The card currently selected by the user.
    \item \textbf{validMoves}: seq of Card --- Cached playable cards for highlighting.
    \item \textbf{statusMessage}: string --- UI message for user feedback (errors/info).
\end{itemize}

\subsubsection{Environment Variables}
\begin{itemize}
    \item \textbf{ClientRuntime}: UI runtime that renders the view model and delivers user input events.
\end{itemize}

\subsubsection{Assumptions}
\begin{itemize}
    \item This module is a client-side view and does not modify authoritative game state.
    \item The current \texttt{RoundState} and player identity are provided by the client application flow.
    \item M12 is available for validating and emitting moves; M13 is available for formatting/displaying scores.
\end{itemize}

\subsubsection{Access Routine Semantics}

\noindent\textbf{Render}(\textit{state, playerId, scores})
\begin{itemize}
    \item transition:
    \begin{itemize}
        \item Calls \texttt{M12.getClientValidMoves(state, playerId)} to update \textbf{validMoves}.
        \item Calls \texttt{M13.renderScoreboard(scores)} to obtain a scoreboard view component.
        \item Constructs a \texttt{ViewModel} that displays: player hand, discard pile/top card, draw control, turn/status indicators, and the rendered scoreboard.
        \item Highlights cards that are in \textbf{validMoves}.
    \end{itemize}
    \item output: Returns the constructed \texttt{ViewModel}.
    \item exception: None. (Errors are represented via \textbf{statusMessage} when possible.)
\end{itemize}

\noindent\textbf{onSelectCard}(\textit{card})
\begin{itemize}
    \item transition:
    \begin{itemize}
        \item Sets \textbf{selectedCard} := \textit{card}.
        \item Clears or updates \textbf{statusMessage}.
    \end{itemize}
    \item output: \texttt{void}.
\end{itemize}

\noindent\textbf{onPlaySelected}(\textit{chosenSuit})
\begin{itemize}
    \item transition:
    \begin{itemize}
        \item Requires \textbf{selectedCard} $\neq$ None.
        \item Calls \texttt{M12.handlePlayCard(state, playerId, selectedCard, chosenSuit)}.
        \item On failure, updates \textbf{statusMessage} with the error context.
    \end{itemize}
    \item output: \texttt{void}.
    \item exception: \texttt{InvalidMoveUI}, \texttt{ConnectionFailed}.
\end{itemize}

\noindent\textbf{onDraw}()
\begin{itemize}
    \item transition:
    \begin{itemize}
        \item Calls \texttt{M12.handleDrawCard(state, playerId)}.
        \item On failure, updates \textbf{statusMessage}.
    \end{itemize}
    \item output: \texttt{void}.
    \item exception: \texttt{InvalidMoveUI}, \texttt{ConnectionFailed}.
\end{itemize}

\subsubsection{Local Functions}
None.

\subsubsection{Considerations}
\begin{itemize}
    \item \textbf{Secret:} the UI layout for presenting the round state and mapping user interactions to controller calls.
    \item M11 is a presentation module; all move validation and move submission are delegated to M12.
    \item Score formatting and display are delegated to M13; M11 does not compute scores.
\end{itemize}


\newpage
\section{MIS of Move Controller Module (M12)}\label{sec:move-controller-module}

\subsection{Module}
Move Controller

\subsection{Uses}
\begin{itemize}
    \item \hyperref[sec:realtime-client-module]{M7 Real-time Client Module}
    \item \hyperref[sec:rules-module]{M16 Rules Module}
\end{itemize}

\subsection{Syntax}

\subsubsection{Exported Constants}
None.

\subsubsection{Exported Access Programs}

\begin{center}
    \begin{tabular}{p{4cm} p{5cm} p{3cm} p{3.5cm}}
        \toprule
        \textbf{Routine Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
        \midrule
        handlePlayCard & state: RoundState, playerId: PlayerID, card: Card, chosenSuit: Suit? & void & InvalidMoveUI, ConnectionFailed \\
        handleDrawCard & state: RoundState, playerId: PlayerID & void & InvalidMoveUI, ConnectionFailed \\
        getClientValidMoves & state: RoundState, playerId: PlayerID & seq of Card & InvalidMoveUI \\
        \bottomrule
    \end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}
\begin{itemize}
    \item \textbf{uiFeedback}: string --- Latest user-facing feedback (error/info).
\end{itemize}

\subsubsection{Environment Variables}
\begin{itemize}
    \item \textbf{ClientRuntime}: UI runtime that provides user input events and dispatches them to this controller.
\end{itemize}

\subsubsection{Assumptions}
\begin{itemize}
    \item M7 is available and can emit actions to the server (M2).
    \item The provided \texttt{state} is the latest client-visible \texttt{RoundState}.
    \item M16 defines the authoritative rule checks used for client-side pre-validation.
\end{itemize}

\subsubsection{Access Routine Semantics}

\noindent\textbf{getClientValidMoves}(\textit{state, playerId})
\begin{itemize}
    \item transition:
    \begin{itemize}
        \item Calls \texttt{M16.getPlayableCards(state, playerId)}.
    \end{itemize}
    \item output: Returns the sequence of playable cards for \textit{playerId}.
    \item exception: \texttt{InvalidMoveUI} if the \textit{state} or \textit{playerId} is invalid for rule evaluation.
\end{itemize}

\noindent\textbf{handlePlayCard}(\textit{state, playerId, card, chosenSuit})
\begin{itemize}
    \item transition:
    \begin{itemize}
        \item Performs client-side pre-validation by checking \texttt{M16.isPlayable(state, playerId, card)}.
        \item If invalid, sets \textbf{uiFeedback} and raises \texttt{InvalidMoveUI}.
        \item If valid, emits a play action to the server via:
        \[
            \texttt{M7.emit(`submitMove', \{action: `play', card: card, chosenSuit: chosenSuit\})}
        \]
    \end{itemize}
    \item output: \texttt{void}.
    \item exception:
    \begin{itemize}
        \item \texttt{InvalidMoveUI} if pre-validation fails.
        \item \texttt{ConnectionFailed} if M7 is not connected.
    \end{itemize}
\end{itemize}

\noindent\textbf{handleDrawCard}(\textit{state, playerId})
\begin{itemize}
    \item transition:
    \begin{itemize}
        \item Performs client-side pre-validation by checking \texttt{M16.mustDraw(state, playerId)}.
        \item If invalid, sets \textbf{uiFeedback} and raises \texttt{InvalidMoveUI}.
        \item If valid, emits a draw action to the server via:
        \[
            \texttt{M7.emit(`submitMove', \{action: `draw'\})}
        \]
    \end{itemize}
    \item output: \texttt{void}.
    \item exception:
    \begin{itemize}
        \item \texttt{InvalidMoveUI} if drawing is not permitted.
        \item \texttt{ConnectionFailed} if M7 is not connected.
    \end{itemize}
\end{itemize}

\subsubsection{Local Functions}
None.

\subsubsection{Considerations}
\begin{itemize}
    \item \textbf{Secret:} mapping user inputs (clicks, selections) into standardized move events sent to the server.
    \item Client-side validation is only for responsiveness; the server remains authoritative.
    \item This module contains no rendering logic and no game-state mutation; it only validates and emits actions.
\end{itemize}


\newpage
\section{MIS of Scoreboard View Module (M13)}\label{sec:scoreboard-view-module}

\subsection{Module}
Scoreboard View

\subsection{Uses}
\begin{itemize}
    \item \hyperref[sec:base-conversion-module]{M18 Base Conversion Module}
\end{itemize}

\subsection{Syntax}

\subsubsection{Exported Constants}
\begin{itemize}
    \item \textbf{DefaultScoreBase}: nat := 10
    \item \textbf{AlternateScoreBase}: nat := 12
\end{itemize}

\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{4.5cm} p{4.5cm} p{3.5cm} p{3.5cm}}
\toprule
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\midrule
renderScoreboard & data: ScoreboardData & ViewModel & InvalidScoreData \\
toggleScoreBase & base: nat & void & InvalidBase \\
formatScore & score: int, base: nat & string & InvalidBase, InvalidScoreData \\
renderRoundSummary & summary: RoundSummaryData & ViewModel & InvalidScoreData \\
animateRoundTransition & from: ViewModel, to: ViewModel & void & None \\
\bottomrule
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}
\begin{itemize}
    \item \textbf{currentBase}: nat := \textbf{DefaultScoreBase}
    \item \textbf{lastRendered}: ViewModel \quad (cached view state for transitions/animations)
\end{itemize}

\subsubsection{Environment Variables}
\begin{itemize}
    \item \textbf{ClientRuntime}: The client-side framework/runtime responsible for rendering UI components and handling user interactions.
    \item \textbf{DisplayPreferences}: User/UI preferences (e.g., preferred score base, accessibility settings).
\end{itemize}

\subsubsection{Assumptions}
\begin{itemize}
    \item Input scores in \texttt{ScoreboardData} are valid integers produced by the game logic.
    \item Dozenal formatting uses the digit-symbol mapping provided by \textbf{M18}.
    \item The client runtime supports re-rendering and simple transitions/animations.
\end{itemize}

\subsubsection{Access Routine Semantics}

\noindent\textbf{renderScoreboard}(\textit{data})
\begin{itemize}
    \item transition: Validate \textit{data} (players, ordering, score values). For each displayed score, call \textbf{formatScore} to produce both decimal and dozenal strings (or the currently selected base). Produce a \texttt{ViewModel} suitable for rendering, and update \textbf{lastRendered}.
    \item output: Return the constructed \texttt{ViewModel}.
    \item exception: \texttt{InvalidScoreData} if \textit{data} is missing required fields or contains invalid score values.
\end{itemize}

\noindent\textbf{toggleScoreBase}(\textit{base})
\begin{itemize}
    \item transition: If \textit{base} is \textbf{DefaultScoreBase} or \textbf{AlternateScoreBase}, set \textbf{currentBase} := \textit{base} and update \textbf{DisplayPreferences} if applicable; otherwise reject.
    \item output: \texttt{void}.
    \item exception: \texttt{InvalidBase} if \textit{base} is not supported.
\end{itemize}

\noindent\textbf{formatScore}(\textit{score, base})
\begin{itemize}
    \item transition: Validate \textit{score}. If \textit{base} = 10, convert \textit{score} to decimal string using standard formatting. If \textit{base} = 12, call \textbf{M18.decimalToDozenal}(\textit{score}) to obtain the dozenal string.
    \item output: Return the formatted score string.
    \item exception: \texttt{InvalidBase} if \textit{base} is unsupported. \texttt{InvalidScoreData} if \textit{score} is not a valid integer (implementation-defined).
\end{itemize}

\noindent\textbf{renderRoundSummary}(\textit{summary})
\begin{itemize}
    \item transition: Validate \textit{summary} fields (round index, deltas, totals). Format all displayed score values using \textbf{formatScore}. Produce a summary \texttt{ViewModel} for end-of-round display.
    \item output: Return the summary \texttt{ViewModel}.
    \item exception: \texttt{InvalidScoreData} if \textit{summary} is malformed or contains invalid scores.
\end{itemize}

\noindent\textbf{animateRoundTransition}(\textit{from, to})
\begin{itemize}
    \item transition: Run client-side UI animation/transition from \textit{from} to \textit{to} (implementation-defined). Update \textbf{lastRendered} := \textit{to}.
    \item output: \texttt{void}.
    \item exception: None.
\end{itemize}

\subsubsection{Local Functions}
None.

\subsubsection{Considerations}
\begin{itemize}
    \item \textbf{Secret:} presentation choices for multi-base score displays and animations for round summaries.
    \item \textbf{Service:} shows standings after each round, presenting both decimal and dozenal scores in a clear, accessible format.
    \item This is a client-side UI module; it should not contain core scoring logic, only formatting and presentation. Numeric base conversion details are delegated to \textbf{M18}.
\end{itemize}

\newpage
\section{MIS of Profile View Module (M14)}\label{sec:profile-view-module}

\subsection{Module}
Profile View

\subsection{Uses}
\begin{itemize}
    \item \hyperref[sec:api-module]{M1 API Module}
\end{itemize}

\subsection{Syntax}

\subsubsection{Exported Constants}
None.

\subsubsection{Exported Access Programs}

\begin{center}
    \begin{tabular}{p{4.5cm} p{5.2cm} p{3.1cm} p{3.2cm}}
        \toprule
        \textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
        \midrule
        Render & state: ProfileViewState & ViewModel & None \\
        loadProfile & session: SessionToken & void & NetworkError, Unauthorized \\
        updateProfile & session: SessionToken, data: ProfileUpdateData & void & NetworkError, InvalidInput, Unauthorized \\
        \bottomrule
    \end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}
\begin{itemize}
    \item \textbf{profileData}: ProfileData? --- Cached profile information of the current user, if available.
    \item \textbf{isLoading}: boolean --- Indicates whether a profile request is in progress.
    \item \textbf{errorMessage}: string? --- Error message to be displayed, if any.
\end{itemize}

\subsubsection{Environment Variables}
\begin{itemize}
    \item \textbf{InputEvents}: External user interaction events (e.g., edit actions, save action).
\end{itemize}

\subsubsection{Assumptions}
\begin{itemize}
    \item A valid session token is available when invoking \textbf{loadProfile} and \textbf{updateProfile}.
    \item Profile data is accessed exclusively through M1; this module does not access persistent storage directly.
\end{itemize}

\subsubsection{Access Routine Semantics}

\noindent\textbf{Render}(\textit{state})
\begin{itemize}
    \item transition: None.
    \item output:
    Returns a \textit{ViewModel} that presents the user's profile information (e.g., username, avatar, statistics summary)
    and indicates whether editing controls are enabled, based on \textbf{isLoading} and \textbf{errorMessage}.
    \item exception: None.
\end{itemize}

\noindent\textbf{loadProfile}(\textit{session})
\begin{itemize}
    \item transition:
    Sets \textbf{isLoading} $\leftarrow$ \texttt{true}. Requests the current user's profile via M1.
    On success, sets \textbf{profileData} to the returned profile and clears \textbf{errorMessage}.
    Sets \textbf{isLoading} $\leftarrow$ \texttt{false}.
    \item output: \texttt{void}.
    \item exception:
    \texttt{Unauthorized} if \textit{session} is invalid or expired.
    \texttt{NetworkError} if the request to M1 fails.
\end{itemize}

\noindent\textbf{updateProfile}(\textit{session, data})
\begin{itemize}
    \item transition:
    Validates \textit{data}. If valid, submits the update request to M1.
    On success, updates \textbf{profileData} to reflect the returned/updated profile and clears \textbf{errorMessage}.
    \item output: \texttt{void}.
    \item exception:
    \texttt{InvalidInput} if \textit{data} fails validation.
    \texttt{Unauthorized} if \textit{session} is invalid or expired.
    \texttt{NetworkError} if the request to M1 fails.
\end{itemize}

\subsubsection{Local Functions}
None.

\subsubsection{Considerations}
\begin{itemize}
    \item \textbf{Secret:} presentation layout decisions and interaction flow for profile rendering and editing.
    \item \textbf{Service:} provides an interface for viewing and updating profile information by delegating all data access to M1.
    \item This module contains no business logic and no persistence logic; it is a presentation and interaction layer.
\end{itemize}

\newpage
\section{MIS of Game Engine Module (M15)}\label{sec:game-engine-module}

\subsection{Module}
Game Engine

\subsection{Uses}
\begin{itemize}
    \item \hyperref[sec:rules-module]{M16 Rules Module}
    \item \hyperref[sec:scoring-module]{M17 Scoring Module}
\end{itemize}

\subsection{Syntax}

\subsubsection{Exported Constants}
\begin{itemize}
    \item \textbf{MaxPlayers}: nat := 2
\end{itemize}

\subsubsection{Exported Access Programs}

\begin{center}
    \begin{tabular}{p{4.5cm} p{4.5cm} p{3.5cm} p{3.5cm}}
        \toprule
        \textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
        \midrule
        createGame & players: seq of PlayerID, options: GameOptions & state: GameState & InvalidSetup \\
        getState & None & GameState & NotInitialized \\
        applyTurn & action: Action & GameState & InvalidAction, NotYourTurn, GameOver \\
        isGameOver & None & boolean & NotInitialized \\
        getWinner & None & PlayerID & NotInitialized, GameNotOver \\
        \bottomrule
    \end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}
\begin{itemize}
    \item \textbf{gameState}: GameState \quad (current authoritative game state)
    \item \textbf{isInitialized}: boolean := \texttt{false}
\end{itemize}

\subsubsection{Environment Variables}
\begin{itemize}
    \item \textbf{RNG}: Source of randomness used for shuffling and dealing (implementation-defined).
\end{itemize}

\subsubsection{Assumptions}
\begin{itemize}
    \item This module is server-side and acts as the source of truth for game state.
    \item The rules for legal moves and round transitions are provided by M16.
    \item Round scoring at the end of a round is provided by M17.
    \item A game is initialized with exactly \textbf{MaxPlayers} players.
\end{itemize}

\subsubsection{Access Routine Semantics}

\noindent\textbf{createGame}(\textit{players, options})
\begin{itemize}
    \item transition: Validate \textit{players} size and uniqueness. Initialize a fresh deck and shuffle using \textbf{RNG}. Call \texttt{M16.initRound(deck, players)} to create the initial round state. Initialize scores for players (0 in decimal, stored as project-defined representation). Set \textbf{gameState} to the newly created state and set \textbf{isInitialized} := \texttt{true}.
    \item output: Return the initialized \texttt{GameState}.
    \item exception: \texttt{InvalidSetup} if \textit{players} is invalid or initialization fails.
\end{itemize}

\noindent\textbf{getState}()
\begin{itemize}
    \item output: Return \textbf{gameState}.
    \item exception: \texttt{NotInitialized} if \textbf{isInitialized} is \texttt{false}.
\end{itemize}

\noindent\textbf{applyTurn}(\textit{action})
\begin{itemize}
    \item transition:
    \begin{enumerate}
        \item Require \textbf{isInitialized} = \texttt{true}.
        \item Check turn ownership from \textbf{gameState} (implementation-defined) and reject if \textit{action.playerId} is not the active player.
        \item If \textit{action} is a play-card action, call \texttt{M16.applyPlay} to update the round state.
        \item If \textit{action} is a draw-card action, call \texttt{M16.applyDraw} to update the round state.
        \item If \texttt{M16.isRoundOver(updatedRoundState)} is \texttt{true}, compute round score via \texttt{M17.computeRoundScore(winner, loserHand)} and update cumulative scores in \textbf{gameState}. Re-initialize the next round (policy-defined) using \texttt{M16.initRound}.
        \item If the overall game end condition is satisfied (policy-defined), mark game over and store winner.
    \end{enumerate}
    Update \textbf{gameState} with the new round state, scores, and turn.
    \item output: Return the updated \texttt{GameState}.
    \item exception: \texttt{NotYourTurn} if \textit{action.playerId} is not the active player. \texttt{InvalidAction} if the action is malformed or illegal under M16. \texttt{GameOver} if the game has already ended.
\end{itemize}

\noindent\textbf{isGameOver}()
\begin{itemize}
    \item output: Return \texttt{true} iff \textbf{gameState} is marked as game-over; otherwise \texttt{false}.
    \item exception: \texttt{NotInitialized} if \textbf{isInitialized} is \texttt{false}.
\end{itemize}

\noindent\textbf{getWinner}()
\begin{itemize}
    \item output: Return the stored winner \texttt{PlayerID}.
    \item exception: \texttt{NotInitialized} if \textbf{isInitialized} is \texttt{false}. \texttt{GameNotOver} if the game is not over yet.
\end{itemize}

\subsubsection{Local Functions}
None.

\subsubsection{Considerations}
\begin{itemize}
    \item \textbf{Secret:} orchestration of round lifecycle, turn sequencing, and how cumulative score/state is stored in \texttt{GameState}.
    \item \textbf{Service:} maintains the authoritative state machine for Crazy Eights gameplay while delegating legality checks to M16 and scoring computation to M17.
    \item This module should remain deterministic given the same shuffled deck seed and action sequence to support testing and debugging.
\end{itemize}


\newpage
\section{MIS of Rules Module (M16)}\label{sec:rules-module}

\subsection{Module}
Rules

\subsection{Uses}
\begin{itemize}
    \item \hyperref[sec:base-conversion-module]{M18 Base Conversion Module}
\end{itemize}

\subsection{Syntax}

\subsubsection{Exported Constants}
\begin{itemize}
    \item \textbf{DozenalBase}: nat := 12
    \item \textbf{DozenalTarget}: string := ``10'' \quad (base-12)
    \item \textbf{DozenalTargetDecimal}: nat := 12 \quad (= M18.dozenalToDecimal(\textbf{DozenalTarget}))
    \item \textbf{InitialHandSize}: nat := 5
\end{itemize}

\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{4.5cm} p{4.5cm} p{3.5cm} p{3.5cm}}
\toprule
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\midrule
initRound & deck: Deck, players: seq of PlayerID & RoundState & InvalidDeck, InvalidPlayers \\
isPlayable & state: RoundState, playerId: PlayerID, card: Card & boolean & InvalidRoundState, InvalidPlayer, InvalidCard \\
getPlayableCards & state: RoundState, playerId: PlayerID & seq of Card & InvalidRoundState, InvalidPlayer \\
applyPlay & state: RoundState, playerId: PlayerID, card: Card, chosenSuit: Suit? & RoundState & IllegalMove, InvalidRoundState, InvalidPlayer, InvalidCard, InvalidSuitChoice \\
mustDraw & state: RoundState, playerId: PlayerID & boolean & InvalidRoundState, InvalidPlayer \\
applyDraw & state: RoundState, playerId: PlayerID & RoundState & EmptyDeck, InvalidRoundState, InvalidPlayer \\
isRoundOver & state: RoundState & boolean & InvalidRoundState \\
\bottomrule
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}
None. (This module is stateless; all game situation is carried in \texttt{RoundState}.)

\subsubsection{Environment Variables}
None.

\subsubsection{Assumptions}
\begin{itemize}
    \item This module currently supports 1v1 gameplay (two players) for round initialization and legality checks.
    \item \texttt{RoundState} contains: \texttt{hands} (mapping from \texttt{PlayerID} to a sequence of \texttt{Card}), \texttt{drawPile}, \texttt{discardPile}, \texttt{topCard}, \texttt{currentTurn}, and an optional \texttt{forcedSuit}.
    \item A \textbf{wildcard} is the rank ``10'' and is always playable regardless of suit/rank/sum constraints.
    \item A \textbf{face card} does not participate in the dozenal-sum rule; it can only be played via match-suit or match-rank (unless it is a wildcard).
    \item The dozenal-sum rule target is base-12 ``10'' (i.e., decimal 12).
\end{itemize}

\subsubsection{Access Routine Semantics}

\noindent\textbf{initRound}(\textit{deck, players})
\begin{itemize}
    \item transition: Validate that \textit{players} contains exactly two distinct players and \textit{deck} has enough cards. Deal \textbf{InitialHandSize} cards from \textit{deck} to each player's hand. Draw one card from the deck to initialize \textit{discardPile} and set \textit{topCard}. Set \textit{forcedSuit} := None. Set \textit{currentTurn} to the starting player (policy-defined).
    \item output: Return the initialized \texttt{RoundState}.
    \item exception: \texttt{InvalidPlayers} if \textit{players} is not a valid 1v1 set. \texttt{InvalidDeck} if the deck lacks sufficient cards or is malformed.
\end{itemize}

\noindent\textbf{isPlayable}(\textit{state, playerId, card})
\begin{itemize}
    \item transition: Validate \textit{state}, \textit{playerId}, and that \textit{card} is in \textit{state.hands[playerId]}. Let \textit{t} := \textit{state.topCard}.
    \item output: Return \texttt{true} iff the following rule holds:
    \begin{itemize}
        \item If \textit{card} is a wildcard (rank 10), then \texttt{true}.
        \item Else if \textit{state.forcedSuit} $\neq$ None, then \texttt{true} iff \textit{card.suit} equals \textit{state.forcedSuit}.
        \item Else (no forced suit), \texttt{true} iff at least one is satisfied:
        \begin{itemize}
            \item match suit: \textit{card.suit} = \textit{t.suit}
            \item match rank: \textit{card.rank} = \textit{t.rank}
            \item dozenal-sum: \textit{card} and \textit{t} are not face cards and \textit{card.rank} + \textit{t.rank} = \textbf{DozenalTargetDecimal}
        \end{itemize}
    \end{itemize}
    \item exception: \texttt{InvalidRoundState} if \textit{state} is malformed. \texttt{InvalidPlayer} if \textit{playerId} is not in the round. \texttt{InvalidCard} if \textit{card} is malformed or not in the player's hand.
\end{itemize}

\noindent\textbf{getPlayableCards}(\textit{state, playerId})
\begin{itemize}
    \item transition: Validate \textit{state} and \textit{playerId}. For each \textit{card} in \textit{state.hands[playerId]}, include it in the result iff \textbf{isPlayable}(\textit{state, playerId, card}) is \texttt{true}.
    \item output: Return the sequence of playable cards (possibly empty).
    \item exception: \texttt{InvalidRoundState} if \textit{state} is malformed. \texttt{InvalidPlayer} if \textit{playerId} is not in the round.
\end{itemize}

\noindent\textbf{applyPlay}(\textit{state, playerId, card, chosenSuit})
\begin{itemize}
    \item transition: Validate \textit{state} and turn order (must be \textit{playerId}'s turn). Require \textbf{isPlayable}(\textit{state, playerId, card}) = \texttt{true}. Remove \textit{card} from \textit{state.hands[playerId]} and push it onto \textit{state.discardPile}; set \textit{state.topCard} := \textit{card}.
    \begin{itemize}
        \item If \textit{card} is a wildcard (rank 10), then \textit{chosenSuit} must be provided; set \textit{state.forcedSuit} := \textit{chosenSuit}.
        \item Else set \textit{state.forcedSuit} := None.
    \end{itemize}
    Advance \textit{state.currentTurn} to the other player.
    \item output: Return the updated \texttt{RoundState}.
    \item exception: \texttt{IllegalMove} if the play is not legal under the rules (including playing out of turn). \texttt{InvalidSuitChoice} if \textit{card} is wildcard and \textit{chosenSuit} is missing/invalid. \texttt{InvalidRoundState}/\texttt{InvalidPlayer}/\texttt{InvalidCard} as applicable.
\end{itemize}

\noindent\textbf{mustDraw}(\textit{state, playerId})
\begin{itemize}
    \item transition: Validate \textit{state} and \textit{playerId}. Compute \textit{playables} := \textbf{getPlayableCards}(\textit{state, playerId}).
    \item output: Return \texttt{true} iff \textit{playables} is empty.
    \item exception: \texttt{InvalidRoundState} if \textit{state} is malformed. \texttt{InvalidPlayer} if \textit{playerId} is not in the round.
\end{itemize}

\noindent\textbf{applyDraw}(\textit{state, playerId})
\begin{itemize}
    \item transition: Validate \textit{state} and turn order. Require \textbf{mustDraw}(\textit{state, playerId}) = \texttt{true}. Pop the top card from \textit{state.drawPile} and add it to \textit{state.hands[playerId]}. (Whether the drawn card may be played immediately is handled by the caller/game flow policy; this module only applies the draw.)
    \item output: Return the updated \texttt{RoundState}.
    \item exception: \texttt{EmptyDeck} if \textit{state.drawPile} is empty. \texttt{InvalidRoundState}/\texttt{InvalidPlayer} as applicable.
\end{itemize}

\noindent\textbf{isRoundOver}(\textit{state})
\begin{itemize}
    \item transition: Validate \textit{state}. Check whether any player's hand is empty.
    \item output: Return \texttt{true} iff $\exists p$ such that \textit{state.hands[p]} is empty; otherwise \texttt{false}.
    \item exception: \texttt{InvalidRoundState} if \textit{state} is malformed.
\end{itemize}

\subsubsection{Local Functions}
None.

\subsubsection{Considerations}
\begin{itemize}
    \item \textbf{Secret:} exact move-validation criteria, including how matching ranks, suits, dozenal sums, and special cards (wildcard) are handled.
    \item \textbf{Service:} confirms whether a proposed play is legal and enumerates valid plays for a player based on the current round situation; also provides helpers to initialize a round and apply state transitions for play/draw.
    \item This module does \textbf{not} compute scoring; scoring is handled by a separate module.
    \item Dozenal interpretation is delegated to \textbf{M18}; this module uses the decimal target (\textbf{DozenalTargetDecimal}) corresponding to base-12 ``10''.
\end{itemize}

\newpage
\section{MIS of Scoring Module (M17)}\label{sec:scoring-module}

\subsection{Module}
Scoring

\subsection{Uses}
\begin{itemize}
    \item \hyperref[sec:base-conversion-module]{M18 Base Conversion Module}
\end{itemize}

\subsection{Syntax}

\subsubsection{Exported Constants}
\begin{itemize}
    \item \textbf{FaceCardScore}: nat := 10
\end{itemize}

\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{4.5cm} p{4.5cm} p{3.5cm} p{3.5cm}}
\toprule
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\midrule
computeRoundScore & winner: PlayerID, loserHand: seq of Card & string & InvalidHand \\
\bottomrule
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}
None.

\subsubsection{Environment Variables}
None.

\subsubsection{Assumptions}
\begin{itemize}
    \item This module is called only when a round ends (i.e., the winner has emptied their hand).
    \item The round score equals the sum of the remaining cards in the loser's hand.
    \item Face cards (J/Q/K) are worth \textbf{FaceCardScore}.
    \item Rank 10 (including wildcard 10) is worth 10.
    \item Numeric cards are worth their rank value.
    \item The returned score is represented in dozenal (base-12) using \textbf{M18.decimalToDozenal}.
\end{itemize}

\subsubsection{Access Routine Semantics}

\noindent\textbf{computeRoundScore}(\textit{winner, loserHand})
\begin{itemize}
    \item transition: Validate \textit{loserHand}. Compute a decimal total:
    \[
        total = \sum_{c \in loserHand} scoreValue(c)
    \]
    where:
    \[
        scoreValue(c) =
        \begin{cases}
        \textbf{FaceCardScore} & \text{if } c \text{ is a face card} \\
        10 & \text{if } rank(c)=10 \\
        rank(c) & \text{otherwise}
        \end{cases}
    \]
    Convert the decimal \textit{total} to dozenal by calling \textbf{M18.decimalToDozenal}(\textit{total}).
    \item output: Return the dozenal score string for the round winner.
    \item exception: \texttt{InvalidHand} if any card in \textit{loserHand} is malformed or has an unsupported rank.
\end{itemize}

\subsubsection{Local Functions}
None.

\subsubsection{Considerations}
\begin{itemize}
    \item \textbf{Secret:} the scoring equation that converts remaining cards into round points.
    \item \textbf{Service:} calculates the round score at the end of a round and returns it in dozenal form for display.
\end{itemize}


\newpage
\section{MIS of Base Conversion Module (M18)}\label{sec:base-conversion-module}

\subsection{Module}
Base Conversion

\subsection{Uses}
None.

\subsection{Syntax}

\subsubsection{Exported Constants}
\begin{itemize}
    \item \textbf{DozenalBase}: nat := 12
    \item \textbf{DecimalBase}: nat := 10
\end{itemize}

\subsubsection{Exported Access Programs}

\begin{center}
\begin{tabular}{p{4.5cm} p{4.5cm} p{3.5cm} p{3.5cm}}
\toprule
\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
\midrule
decimalToDozenal & n: int & string & InvalidNumberFormat \\
dozenalToDecimal & s: string & int & InvalidNumberFormat \\
normalizeDozenal & s: string & string & InvalidNumberFormat \\
isValidDozenal & s: string & boolean & None \\
\bottomrule
\end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}
None.

\subsubsection{Environment Variables}
None.

\subsubsection{Assumptions}
\begin{itemize}
    \item The dozenal representation uses a fixed, consistent mapping between values and symbols for digits (including the two extra digits beyond 0--9).
    \item Input strings for conversion do not contain whitespace unless explicitly handled by \texttt{normalizeDozenal}.
\end{itemize}

\subsubsection{Access Routine Semantics}

\noindent\textbf{decimalToDozenal}(\textit{n})
\begin{itemize}
    \item transition: Convert integer \textit{n} from base \textbf{DecimalBase} to base \textbf{DozenalBase} using repeated division and remainder; map each remainder to the corresponding dozenal digit symbol; produce the resulting string (including a sign if \textit{n} $<$ 0).
    \item output: Return a dozenal \texttt{string} representing \textit{n}.
    \item exception: \texttt{InvalidNumberFormat} if \textit{n} is not a valid finite integer (implementation-defined; e.g., NaN or non-integer input in a loosely-typed context).
\end{itemize}

\noindent\textbf{dozenalToDecimal}(\textit{s})
\begin{itemize}
    \item transition: Normalize \textit{s} (optional). Validate that every character is a recognized dozenal digit symbol (and optional leading sign). Compute the decimal value by positional evaluation in base \textbf{DozenalBase}.
    \item output: Return the decimal \texttt{int} value represented by \textit{s}.
    \item exception: \texttt{InvalidNumberFormat} if \textit{s} contains invalid digits/symbols or is otherwise malformed.
\end{itemize}

\noindent\textbf{normalizeDozenal}(\textit{s})
\begin{itemize}
    \item transition: Standardize \textit{s} into canonical dozenal format (e.g., trim whitespace, normalize casing, map alternate symbols to the project-standard digit symbols).
    \item output: Return the normalized dozenal \texttt{string}.
    \item exception: \texttt{InvalidNumberFormat} if \textit{s} cannot be normalized into a valid dozenal representation.
\end{itemize}

\noindent\textbf{isValidDozenal}(\textit{s})
\begin{itemize}
    \item transition: Check whether \textit{s} is a syntactically valid dozenal string under the module's digit-symbol mapping.
    \item output: Return \texttt{true} iff \textit{s} is valid; otherwise return \texttt{false}.
    \item exception: None.
\end{itemize}

\subsubsection{Local Functions}
None.

\subsubsection{Considerations}
\begin{itemize}
    \item \textbf{Secret:} the mapping of digits and symbols used to move between decimal and dozenal numbers.
    \item \textbf{Service:} translates numeric values to and from dozenal form for scoring logic and UI presentation.
    \item This is a behaviour-hiding utility module: callers rely on the conversion API without knowing the digit-symbol mapping details.
\end{itemize}


\newpage
\section{MIS of Game Actions Module (M19)}\label{sec:game-actions-module}

\subsection{Module}
Game Actions Module

\subsection{Uses}
\begin{itemize}
    \item \hyperref[sec:game-engine-module]{M15 Game Engine Module}
    \item \hyperref[sec:rules-module]{M16 Rules Module}
\end{itemize}

\subsection{Syntax}

\subsubsection{Exported Constants}
None.

\subsubsection{Exported Access Programs}
\begin{center}

    \begin{tabular}{p{3.5cm} p{3.5cm} p{3cm} >{\raggedright\arraybackslash}p{4cm}}
        \toprule
        \textbf{Routine Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
        \midrule
        createAction & ActionType, Parameters & Action & InvalidActionType \\
        validateAction & Action, GameState & Boolean & InvalidMoveException \\
        executeAction & Action, GameState & GameState & ActionExecutionError \\
        undoAction & Action, GameState & GameState & None \\
        \bottomrule
    \end{tabular}
\end{center}

\subsection{Semantics}

\subsubsection{State Variables}
\begin{itemize}
    \item \textbf{pendingActions}: a queue of unexecuted player actions.
    \item \textbf{lastAction}: most recent action for rollback or replay.
\end{itemize}

\subsubsection{Environment Variables}
\begin{itemize}
    \item Backend execution environment.
\end{itemize}

\subsubsection{Assumptions}
\begin{itemize}
    \item Each action follows the command pattern and can be validated independently.
    \item The game engine (M15) ensures single-threaded execution for action safety.
\end{itemize}

\subsubsection{Access Routine Semantics}
\noindent\textbf{createAction}(\textit{ActionType, Parameters})
\begin{itemize}
    \item output: constructs an action object from parameters (e.g., play card 8 spade).
\end{itemize}

\noindent\textbf{validateAction}(\textit{Action, GameState})
\begin{itemize}
    \item output: checks if the action is allowed under current rules (by calling M16).
\end{itemize}

\noindent\textbf{executeAction}(\textit{Action, GameState})
\begin{itemize}
    \item transition: applies changes to game state (by calling M15) and notifies observers.
    \item output: \texttt{GameState}.
\end{itemize}

\noindent\textbf{undoAction}(\textit{Action, GameState})
\begin{itemize}
    \item transition: reverses the last applied change for testing or debugging.
    \item output: \texttt{GameState}.
\end{itemize}

\subsubsection{Local Functions}
\begin{itemize}
    \item \texttt{serializeAction()}: converts an action into a string or JSON for replay logging.
\end{itemize}

\subsubsection{Considerations}
\begin{itemize}
    \item This module improves maintainability by isolating gameplay logic into self-contained actions, enabling undo/redo and deterministic testing.
\end{itemize}



%~\newpage
%
%\section{MIS of \wss{Module Name}} \label{Module} \wss{Use labels for
%  cross-referencing}
%
%\wss{You can reference SRS labels, such as R\ref{R_Inputs}.}
%
%\wss{It is also possible to use \LaTeX for hypperlinks to external documents.}
%
%\subsection{Module}
%
%\wss{Short name for the module}
%
%\subsection{Uses}
%
%
%\subsection{Syntax}
%
%\subsubsection{Exported Constants}
%
%\subsubsection{Exported Access Programs}
%
%\begin{center}
%\begin{tabular}{p{2cm} p{4cm} p{4cm} p{2cm}}
%\hline
%\textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions} \\
%\hline
%\wss{accessProg} & - & - & - \\
%\hline
%\end{tabular}
%\end{center}
%
%\subsection{Semantics}
%
%\subsubsection{State Variables}
%
%\wss{Not all modules will have state variables.  State variables give the module
%  a memory.}
%
%\subsubsection{Environment Variables}
%
%\wss{This section is not necessary for all modules.  Its purpose is to capture
%  when the module has external interaction with the environment, such as for a
%  device driver, screen interface, keyboard, file, etc.}
%
%\subsubsection{Assumptions}
%
%\wss{Try to minimize assumptions and anticipate programmer errors via
%  exceptions, but for practical purposes assumptions are sometimes appropriate.}
%
%\subsubsection{Access Routine Semantics}
%
%\noindent \wss{accessProg}():
%\begin{itemize}
%\item transition: \wss{if appropriate} 
%\item output: \wss{if appropriate} 
%\item exception: \wss{if appropriate} 
%\end{itemize}
%
%\wss{A module without environment variables or state variables is unlikely to
%  have a state transition.  In this case a state transition can only occur if
%  the module is changing the state of another module.}
%
%\wss{Modules rarely have both a transition and an output.  In most cases you
%  will have one or the other.}
%
%\subsubsection{Local Functions}
%
%\wss{As appropriate} \wss{These functions are for the purpose of specification.
%  They are not necessarily something that is going to be implemented
%  explicitly.  Even if they are implemented, they are not exported; they only
%  have local scope.}

\newpage

\bibliographystyle {plainnat}
\bibliography {../../../refs/References}

\newpage

\section{Appendix} \label{Appendix}

\wss{Extra information if required}

\newpage{}

\section*{Appendix --- Reflection}

\wss{Not required for CAS 741 projects}

The information in this section will be used to evaluate the team members on the
graduate attribute of Problem Analysis and Design.

\input{../../Reflection.tex}

\begin{enumerate}
  \item What went well while writing this deliverable? 
  \item What pain points did you experience during this deliverable, and how
    did you resolve them?
  \item Which of your design decisions stemmed from speaking to your client(s)
  or a proxy (e.g. your peers, stakeholders, potential users)? For those that
  were not, why, and where did they come from?
  \item While creating the design doc, what parts of your other documents (e.g.
  requirements, hazard analysis, etc), it any, needed to be changed, and why?
  \item What are the limitations of your solution?  Put another way, given
  unlimited resources, what could you do to make the project better? (LO\_ProbSolutions)
  \item Give a brief overview of other design solutions you considered.  What
  are the benefits and tradeoffs of those other designs compared with the chosen
  design?  From all the potential options, why did you select the documented design?
  (LO\_Explores)
\end{enumerate}


\end{document}